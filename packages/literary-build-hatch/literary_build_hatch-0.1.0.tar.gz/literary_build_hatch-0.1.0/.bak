from hatchling.builders.hooks.plugin.interface import BuildHookInterface

import os
import pathlib
import shutil

from literary.core.package import PackageBuilder
from literary.core.config import find_project_config, load_project_config


class LiteraryBuildHook(BuildHookInterface):
    PLUGIN_NAME = 'literary'

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # Find literary config file
        root_path = pathlib.Path(self.root)
        config_path = find_project_config(root_path)
        if config_path.parent != root_path:   
            raise RuntimeError("missing literary config")
            
        config = load_project_config(config_path)

        # Build Python files
        self.__builder = PackageBuilder(config=config)

        # Ensure that we own build directory
        if self.__builder.generated_path == root_path:
            raise RuntimeError("cannot generate inside root")
    
        self.__config_include = None
        self.__config_exclude = None
        self.__include_spec = None
        self.__exclude_spec = None

    @property
    def config_include(self):
        if self.__config_include is None:
            patterns = self.config.get('include', [])
            if isinstance(patterns, list):
                for i, pattern in enumerate(patterns, 1):
                    if not isinstance(pattern, str):
                        raise TypeError(
                            f'Pattern #{i} of option `include` for build hook `{self.PLUGIN_NAME}` must be a string'
                        )
                    elif not pattern:
                        raise ValueError(
                            f'Pattern #{i} of option `include` for build hook `{self.PLUGIN_NAME}` '
                            f'cannot be an empty string'
                        )
            else:
                raise TypeError(f'Option `include` for build hook `{self.PLUGIN_NAME}` must be an array')

            self.__config_include = patterns

        return self.__config_include

    @property
    def config_exclude(self):
        if self.__config_exclude is None:
            patterns = self.config.get('exclude', [])
            if isinstance(patterns, list):
                for i, pattern in enumerate(patterns, 1):
                    if not isinstance(pattern, str):
                        raise TypeError(
                            f'Pattern #{i} of option `exclude` for build hook `{self.PLUGIN_NAME}` must be a string'
                        )
                    elif not pattern:
                        raise ValueError(
                            f'Pattern #{i} of option `exclude` for build hook `{self.PLUGIN_NAME}` '
                            f'cannot be an empty string'
                        )
            else:
                raise TypeError(f'Option `exclude` for build hook `{self.PLUGIN_NAME}` must be an array')

            self.__config_exclude = patterns

        return self.__config_exclude

    @property
    def include_spec(self):
        if self.__include_spec is None:
            if self.config_include:
                self.__include_spec = pathspec.PathSpec.from_lines(
                    pathspec.patterns.GitWildMatchPattern, self.config_include
                )
            elif self.build_config.include_spec is not None:
                self.__include_spec = self.build_config.include_spec
            else:
                raise ValueError(f'Option `include` for build hook `{self.PLUGIN_NAME}` is required')

        return self.__include_spec

    @property
    def exclude_spec(self):
        if self.__exclude_spec is None:
            if self.config_exclude:
                self.__exclude_spec = pathspec.PathSpec.from_lines(
                    pathspec.patterns.GitWildMatchPattern, self.config_exclude
                )
            else:
                self.__exclude_spec = self.build_config.exclude_spec

        return self.__exclude_spec

    def include_path(self, relative_path):
        return self.include_spec.match_file(relative_path) and not self.path_is_excluded(relative_path)

    def path_is_excluded(self, relative_path):
        if self.exclude_spec is None:  # no cov
            return False

        return self.exclude_spec.match_file(relative_path)

    @property
    def included_files(self):
        if self.__included_files is None:
            included_files = []

            for root, dirs, files in os.walk(self.root):
                relative_path = os.path.relpath(root, self.root)

                # First iteration
                if relative_path == '.':
                    relative_path = ''

                dirs[:] = sorted(
                    d
                    for d in dirs
                    # The trailing slash is necessary so e.g. `bar/` matches `foo/bar`
                    if not self.path_is_excluded('{}/'.format(os.path.join(relative_path, d)))
                )

                for f in sorted(files):
                    if not f.endswith('.py'):
                        continue

                    relative_file_path = os.path.join(relative_path, f)
                    if self.include_path(relative_file_path):
                        included_files.append(relative_file_path)

            self.__included_files = included_files

        return self.__included_files
    
    def initialize(self, version, build_data):
        if self.target_name != 'wheel':
            return

        self.__builder.build()

        # Ensure generated files are included in wheel
        force_include = {}
        for root, dirs, files in os.walk(self.__builder.generated_path):
            relative_path = os.path.relpath(root, self.root)
        
            assert relative_path != '.'

            dirs[:] = sorted(
                d
                for d in dirs
                # The trailing slash is necessary so e.g. `bar/` matches `foo/bar`
                if not self.path_is_excluded('{}/'.format(os.path.join(relative_path, d)))
            )

            for f in files:
                relative_file_path = os.path.join(relative_path, f)
                if self.include_path(relative_file_path):
                    absolute_file_path = os.path.join(
                        self.root, 
                        relative_file_path
                    )
                    distribution_path = os.path.relpath(
                        self.__builder.generated_path,
                        absolute_file_path
                    )
                    force_include[absolute_file_path] = distribution_path

                    
        build_data["force-include"] = force_include

    def clean(self, versions):
        # Remove contents of generated directory
        for path in self.__builder.generated_path.iterdir():
            if path.is_dir():
                shutil.rmtree(path)
            else:
                os.unlink(path)
