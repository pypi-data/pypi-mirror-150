debug: false

#    """
#    Logic:
#        1- load the history table for the chaselist dos sync table only include the records with
#           the last job_id present in the history table
#        2- create the full data for chaselist dos
#        3- compare the full data against the last history data to create the incremental table with 3 operations
#         INSERT if records are present in the full table but not in the history (using the pk for the comparison
#         DELETE if records are present in the history  table but not in the full table
#         UPDATE If recorda are present in both tables (history and full) but the hash value is different
#    """

## Files to Load / Create View
variables:
  - project_root_path = {config.project_root_path}
  - client = {config.client}
  - aggr_location =  {config.aggr_location}
  - debug = True

Extract:
  chaselist_dos_history:
    type: parquet
    location: "{aggr_location}/chaselist_dos_history/"
  EA_Dx:
    type: parquet
    location: "{project_root_path}/{client}/EA_Dx/"
  providers_full:
    type: parquet
    location: "{aggr_location}/providers_full/"
  job:
    type: postgres
    conn_config_name: cadmium_postgres_db
    table_name: job
    skip_if_local: true

Transform:
  cad_job:
    sql: >-
      With LastJob as (
        SELECT
          max(id) as last_job_id,
          max(client_name) as client_name
          FROM job
          WHERE status = 'CLOSED' and client_name ='{client}'
        )
      SELECT
        max(j.id) as cad_job_id, max(coalesce(l.last_job_id,0)) as last_job_id
        FROM job j
        inner join LastJob l on j.client_name = l.client_name
        WHERE status = 'OPEN'
    cache: true
    create_local_job_id: true

#  previous_load:
#    sql: >-
#      WITH allrows as (
#         SELECT
#            * , row_number() over(partition by member_id, provider_id, date_of_service_year order by job_id desc) as r
#         FROM chaselist_dos_history)
#      SELECT
#         member_id,
#         provider_id,
#         date_of_service_year,
#         count,
#         list_of_dos,
#         hash_value,
#         job_id
#      FROM allrows
#      WHERE  r=1
#    cache: true

  # previous job should ONLY include the table keys , hash values and job id for the previous job_id for the specific client
  previous_load:
    sql: >-
      SELECT
         member_id,
         provider_id,
         date_of_service_year,
         hash_value,
         job_id
      FROM chaselist_dos_history m
      INNER JOIN cad_job  c on c.last_job_id =m.job_id
    cache: true

  Load_EA_Dx:
    sql: >-
      SELECT
        Provider_Id AS provider_id,
        Member_Id AS member_id,
        cast(DOS as date) as date_of_service,
        YEAR(DOS) As date_of_service_year,
        cast(FALSE as Boolean) as is_deleted,
        Dx_Status as dx_status
      FROM EA_Dx

  # get max count list of dos by member_id, provider_id, date_of_service_year.
  chaselist_dos:
    sql: >-
      WITH ONE AS
      (
      SELECT
        dx.provider_id,
        dx.member_id,
        dx.date_of_service_year,
        collect_set(DATE_FORMAT(dx.date_of_service,'MM/dd/yyyy')) OVER (PARTITION BY dx.member_id, dx.provider_id, dx.date_of_service_year ORDER BY dx.date_of_service) AS list_of_dos_sorted_distinct
      FROM Load_EA_Dx dx
      JOIN providers_full p
      ON dx.provider_id = p.provider_id
      WHERE dx.dx_status != 'Suspect'
      AND !dx.is_deleted OR dx.is_deleted IS NULL
      AND p.is_acceptable
      ),
      TWO AS (
      SELECT
      *,
      SIZE(list_of_dos_sorted_distinct) AS count
      FROM ONE
      ),
      THREE AS (
      SELECT 
      *, 
      row_number() over(partition by member_id, provider_id, date_of_service_year order by count desc) as rn
      FROM TWO
      )
      SELECT 
      * ,
      CONCAT_WS(',', sort_array(list_of_dos_sorted_distinct)) AS list_of_dos
      FROM THREE
      WHERE rn = 1

  chaselist_dos_full:
    sql: >-
      SELECT
        member_id,
        provider_id,
        date_of_service_year,
        count,
        list_of_dos,
        hash(
        member_id,
        provider_id,
        date_of_service_year,
        count,
        list_of_dos
        ) as hash_value,
        ( select cad_job_id from cad_job )  as job_id
      FROM chaselist_dos

    cache: true

  chaselist_dos_incremental:
    sql: >-
      WITH new_rows as (
           SELECT
            a.hash_value,
            'INSERT' as operation,
            a.job_id,
            a.member_id,
            a.provider_id,
            a.date_of_service_year,
            a.count,
            a.list_of_dos
           FROM chaselist_dos_full a
           LEFT JOIN previous_load b
           ON a.member_id = b.member_id
           AND a.provider_id = b.provider_id
           AND a.date_of_service_year = b.date_of_service_year
           WHERE b.member_id IS NULL OR b.provider_id IS NULL OR b.date_of_service_year IS NULL),
      delete_rows as (
           SELECT
            a.hash_value,
            'DELETE' as operation,
             ( select cad_job_id from cad_job )  as job_id,
            a.member_id,
            CAST(a.provider_id AS STRING),
            CAST(a.date_of_service_year AS INT),
            CAST(a.count AS INT),
            CAST(a.list_of_dos AS STRING)
           FROM previous_load a
           LEFT JOIN chaselist_dos_full b
           ON a.member_id = b.member_id
           AND a.provider_id = b.provider_id
           AND a.date_of_service_year = b.date_of_service_year
           WHERE b.member_id IS NULL OR b.provider_id IS NULL OR b.date_of_service_year IS NULL),
      update_rows as (
           SELECT
            a.hash_value,
            'UPDATE' as operation,
            a.job_id,
            a.member_id,
            a.provider_id,
            a.date_of_service_year,
            a.count,
            a.list_of_dos
           FROM chaselist_dos_full a
           INNER JOIN previous_load b
           ON a.member_id = b.member_id
           AND a.provider_id = b.provider_id
           AND a.date_of_service_year = b.date_of_service_year
           WHERE a.hash_value <> b.hash_value)
      SELECT * FROM new_rows
      UNION
      SELECT * FROM delete_rows
      UNION
      SELECT * FROM update_rows

    cache: true
#
### Note: Load tables have to be same as Extract tables.
Load:
  chaselist_dos_full:
    load_1:
      type: parquet
      location: '{aggr_location}/chaselist_dos_full'
      mode: overwrite

  chaselist_dos_incremental:
    load_1:
      type: parquet
      location: '{project_root_path}/{client}/sync/chaselist_dos_incremental'
      mode: overwrite
    load_to_postgres:
      type: postgres
      conn_config_name: epia_medicare_postgres
      table_name: load_chaselist_dos
      mode: overwrite
