# Introduction to OpenSees

<p>__NOTOC__</p>
<h2 id="context_for_simulation_in_earthquake_engineering">Context for
Simulation in Earthquake Engineering</h2>
<ul>
<li>Research and practice is moving towards Performance-Based Seismic
Engineering, which depends on high-fidelity models and simulation to
assess performance.</li>
<li>Simulation models capture knowledge from tests to leverage
investment in limited experimentation.</li>
<li>Community-based, open-source software for simulation promotes
innovation in research and advanced applications for practice.</li>
<li>NEES infrastructure is supporting OpenSees to provide simulation
capability and integration with NEESit services for NEES research.</li>
</ul>
<h2 id="what_is_opensees">What is OpenSees?</h2>
<ul>
<li>A software framework for simulation applications in earthquake
engineering using finite element methods. OpenSees is not a code.</li>
<li>A communication mechanism for exchanging and building upon research
accomplishments.</li>
<li>As open-source software, it has the potential for a community code
for earthquake engineering.</li>
</ul>
<h2 id="why_is_opensees_opensource">Why is OpenSees OpenSource?</h2>
<ul>
<li>Linus’s Law: “Given enough eyeballs, all bugs are shallow”.</li>
<li>Zero cost software attracts users!</li>
<li>Prevents community from losing software. (especially true in a
research community)</li>
<li>Allows Community to examine new ideas. (vital in a research
community were new ideas can be tested and validated by all instead of
being hidden behind some theory in a paper and limited to researchers
own test data)</li>
</ul>
<h2 id="simulation_framework">Simulation Framework</h2>
<dl>
<dt>Computation</dt>
<dd>
Algorithms
</dd>
<dd>
Solvers
</dd>
<dd>
Parallel/distributed computing
</dd>
<dt>Information Technology</dt>
<dd>
Software framework
</dd>
<dd>
Databases
</dd>
<dd>
Visualization
</dd>
<dd>
Internet/grid computation
</dd>
<dt>Models</dt>
<dd>
Simulation models
</dd>
<dd>
Performance models
</dd>
<dd>
Limit state models
</dd>
<dd>
Material
</dd>
<dd>
component
</dd>
<dd>
system models
</dd>
</dl>
<h2 id="opensees_approach_to_simulation">OpenSees Approach to
Simulation</h2>
<dl>
<dt>Basic approach</dt>
<dd>
Modular software design for implementing and integrating modeling,
numerical methods, and IT for scalable, robust simulation
</dd>
<dd>
Focus on capabilities needed for performance-based engineering
</dd>
<dd>
Programmable interfaces
</dd>
<dt>Most users</dt>
<dd>
a “code” for nonlinear analysis
</dd>
<dd>
Fully scriptable.
</dd>
<dt>Generally</dt>
<dd>
a software framework for developing simulation applications
</dd>
</dl>
<h2 id="remember_opensees_is_a_software_framework">Remember OpenSees is
a Software Framework</h2>
<ul>
<li>A framework is NOT an executable.</li>
<li>A framework IS a set of cooperating software components for building
applications in a specific domain.</li>
<li>The OpenSees framework is written primarily in the objectoriented
language C++; though other languages namely C and Fortran are also
used.</li>
<li>The abstract classes in the OpenSees framework define the interface.
The concrete subclasses that exist the implementations. Other classes
can be provided to extend the capabilities of the framework</li>
<li>Most users, however, will use OpenSees.exe which is, indeed, an
executable.</li>
</ul>
<h2 id="basics_of_object_oriented_programming">Basics of Object-Oriented
Programming</h2>
<ul>
<li>In object-oriented programming, the program is seen as a collection
of objects. Each object is capable of receiving messages, processing
data, and sending messages to other objects.</li>
<li>Each object is of a particular type or Class. The class defines the
data and methods of an object.</li>
<li>3 basic relationships between classes</li>
</ul>
<dl>
<dt></dt>
<dd>
IS-A (Truss is an Element)
</dd>
<dd>
KNOWS-A (Truss knows a Node)
</dd>
<dd>
HAS-A (Truss has a Material)
</dd>
</dl>
<h2 id="how_people_use_opensees">How People Use OpenSees</h2>
<ul>
<li>Provide their own main() function in C++ and link to framework.</li>
<li>Use OpenSees interpreterS. These are extensions of the Tcl
interpreter for finite element analysis which are built using the
OpenSees framework.
<ul>
<li>OpenSees.exe (Sequential-computing version)</li>
<li>OpseseesSP.exe (Parallel-computing version)</li>
<li>OpenSeesMP.exe (Parallel-computing version)</li>
</ul></li>
</ul>
<h2 id="what_is_tcl">What is Tcl</h2>
<p>Tcl is a programming language.</p>
<ul>
<li>It is a string based command language.</li>
<li>Variables and variable substitution</li>
<li>Expression evaluation</li>
<li>Basic control structures (if , while, for, foreach)</li>
<li>Procedures</li>
<li>File manipulation</li>
<li>Sourcing other files.</li>
<li>Comand syntax:</li>
</ul>
<dl>
<dt></dt>
<dd>
<dl>
<dt></dt>
<dd>
<em>command arg1 arg2 …</em>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>Help
<ul>
<li><a
href="http://dev.scriptics.com/scripting/primer.html">dev.scriptics.com/scripting/primer.html</a></li>
<li>Practical Programming in Tcl and Tk, Brent B. Welch.</li>
</ul></li>
</ul>
<h2 id="what_is_an_interpreter">What is an interpreter</h2>
<ul>
<li>Interpreters (Tcl,Perl, Matlab, Ruby) are programs that execute
programs written in a programming language immediately.</li>
<li>There is no separate compilation &amp; linking.</li>
<li>An interpreted program runs slower than a compiled one</li>
</ul>
<h2 id="example_tcl">Example Tcl</h2>
<ul>
<li>Variables &amp; variable substitution</li>
</ul>
<p>&gt;set a 1 &gt;1 &gt;set b a &gt;a &gt;set b $a &gt;1</p>
<ul>
<li>Expression evaluation</li>
</ul>
<p>&gt;expr 2 + 3 &gt; 5 &gt;set b [expr 2 + $b] &gt; 3</p>
<ul>
<li>File manipulation</li>
</ul>
<p>&gt;set fileId [open tmp w] &gt;?? &gt;puts $fileId “hello” &gt;close
$fileID &gt;type tmp hello</p>
<ul>
<li>Sourcing files</li>
</ul>
<p>&gt;source Example1.tcl</p>
<ul>
<li>Procedures and control structures</li>
</ul>
<p>for {set i 1} {$i &lt; 10} {incr i 1} { puts “i equals $i” } set sum
0 foreach value {1 2 3 4} { set sum [expr $sum + $value] } set $ sum
&gt;10 &gt;proc guess {value} { global sum if {$value &lt; $sum} { puts
“too low” } else { if {$value &gt; $sum} { puts “too high” } else { puts
“you got it!”} } } &gt; guess 9 too low</p>
<h2 id="main_abstractions_in_opensees_framework">Main Abstractions in
OpenSees Framework</h2>
<dl>
<dt>ModelBuilder</dt>
<dd>
Constructs the objects in the model and adds them to the domain.
</dd>
<dt>Domain (Central component)</dt>
<dd>
Holds the state of the model at time t and (t + dt)
</dd>
<dt>Analysis</dt>
<dd>
Moves the model from state at time t to state at time (t + dt)
</dd>
<dt>Recorder</dt>
<dd>
Monitors user defined parameters in the model during the analysis
</dd>
</dl>
<h2 id="opensees_interpreters">OpenSees Interpreters</h2>
<p>The OpenSees interpreters are tcl interpreters which have been
extended to include commands for finite element analysis:</p>
<dl>
<dt></dt>
<dd>
1. Modeling - create nodes, elements, loads and constraints
</dd>
<dd>
2. Analysis - specify the analysis procedure.
</dd>
<dd>
3. Output specification - specify what it is you want to monitor during
the analysis.
</dd>
</dl>
<p>Being interpreters, this means that the files you create and submit
to the OpenSees interpreters are not input files. You are creating and
submitting PROGRAMS. The OpenSees <a href="model_Command"
title="wikilink">model Command</a> adds the OpenSees modeling commands
to the Tcl interpreter.</p>
<h2 id="modeling_features">Modeling Features</h2>
<p>Modeling Features are used to define the model and the loads held in
the domain</p>
<dl>
<dt>Model</dt>
<dd>
The OpenSees <a href="model_command" title="wikilink">model command</a>
enables the model definition
</dd>
<dt>Nodes</dt>
<dd>
The OpenSees <a href="node_command" title="wikilink">node command</a>
</dd>
<dt>Masses</dt>
<dd>
The OpenSees <a href="mass_Command" title="wikilink">mass Command</a>
</dd>
<dt>Nodal constraints &amp; Boundary Conditions</dt>
<dd>
The OpenSees <a href="constraints_commands" title="wikilink">constraints
commands</a> defines the constraints between degrees of freedom.
</dd>
<dt>Materials</dt>
<dd>
There are two types of materials
<dl>
<dt></dt>
<dd>
The OpenSees <a href="uniaxialMaterial_Command"
title="wikilink">uniaxialMaterial Command</a> defines materials with a
unique one-dimensional stress-strain (force-deformation) relationship
</dd>
<dd>
The OpenSees <a href="nDMaterial_Command" title="wikilink">nDMaterial
Command</a> defines multi-dimensional materials
</dd>
</dl>
</dd>
<dt>Sections</dt>
<dd>
The OpenSees <a href="section_Command" title="wikilink">section
Command</a> defines different types of element cross-sections, ranging
from uniaxial elastic sections to fiber sections\
</dd>
<dt>Elements</dt>
<dd>
The OpenSees <a href="element_Command" title="wikilink">element
Command</a> defines element types and element connectivity within the
model
</dd>
<dt>Block-generation of elements</dt>
<dd>
The OpenSees <a href="block_Command" title="wikilink">block Command</a>
generates meshes of quadrilateral or brick finite element
</dd>
<dt>Node &amp; Element Regions</dt>
<dd>
The OpenSees <a href="region_Command" title="wikilink">region
Command</a> labels a group of nodes and elements
</dd>
<dt>Geometric Transformation</dt>
<dd>
The OpenSees <a href="Geometric_Transformation_Command"
title="wikilink">Geometric Transformation Command</a> is used to define
the relationtionship between element force and deformation quantities
from the global coordinate system to the element basic system (local
coordinates)
</dd>
<dt>Time Series</dt>
<dd>
The OpenSees <a href="Time_Series_Command" title="wikilink">Time Series
Command</a> defines a time series that is used within the load pattern
</dd>
<dt>Load Pattern</dt>
<dd>
The OpenSees <a href="pattern_Command" title="wikilink">pattern
Command</a> imposes element and/or nodal loads and/or constraints
</dd>
<dt>Damping</dt>
<dd>
The OpenSees <a href="Rayleigh_Damping_Command"
title="wikilink">Rayleigh Damping Command</a> defines the mass and
stiffness-proportional damping parameters
</dd>
</dl>
<h2 id="analysis_definition_and_features">Analysis definition and
features</h2>
<p>The analysis-definition part of OpenSees allows the user to define
the different linear and nonlinear analysis tools available. For each
analysis, the following items need to be defined, preferably in this
order:</p>
<dl>
<dt>constraints : The OpenSees <a href="constraints_Command"
title="wikilink">constraints Command</a> is used to construct the
ConstraintHandler object. Constraints enforce a relationship between
degrees-of-freedom. The ConstraintHandler object determines how the
constraint equations are enforced in the analysis.</dt>

</dl>
<dl>
<dt>numberer : The OpenSees <a href="numberer_Command"
title="wikilink">numberer Command</a> is used to construct the
DOF_Numberer object. The DOF_Numberer object determines the mapping
between equation numbers and degrees-of-freedom -- how
degrees-of-freedom are numbered.</dt>

</dl>
<dl>
<dt>system : The OpenSees <a href="system_Command"
title="wikilink">system Command</a> is used to construct the LinearSOE
and LinearSolver objects to store and solve the system of equations in
the analysis.</dt>

</dl>
<dl>
<dt>test : The OpenSees <a href="test_Command" title="wikilink">test
Command</a> is used to construct a ConvergenceTest object. Certain
SolutionAlgorithm objects require a ConvergenceTest object to determine
if convergence has been achieved at the end of an iteration step.</dt>

</dl>
<dl>
<dt>algorithm : The OpenSees <a href="algorithm_Command"
title="wikilink">algorithm Command</a> is used to construct a
SolutionAlgorithm object, which determines the sequence of steps taken
to solve the non-linear equation.</dt>

</dl>
<dl>
<dt>integrator : The OpenSees <a href="integrator_Command"
title="wikilink">integrator Command</a> is used to construct the
Integrator object. The Integrator object determines the meaning of the
terms in the system of equation object. The Integrator object is used
for the following:</dt>

</dl>
<p>::*determine the predictive step for time t+dt</p>
<p>::*specify the tangent matrix and residual vector at any
iteration</p>
<p>::*determine the corrective step based on the displacement increment
dU</p>
<dl>
<dt>analysis : The OpenSees <a href="analysis_Command"
title="wikilink">analysis Command</a> is used to construct the Analysis
object. This analysis object is constructed with the component objects
previously created by the analyst. All currently-available analysis
objects employ incremental solution strategies. There are three types of
analysis currently available:</dt>

</dl>
<p>::*Static - for static analysis</p>
<p>::*Transient - for transient analysis with constant time step</p>
<p>::*VariableTransient - for transient analysis with variable time
step</p>
<h3 id="analysis_execution">Analysis execution</h3>
<dl>
<dt>analyze</dt>
<dd>
The analysis is executed using the OpenSees <a href="analyze_Command"
title="wikilink">analyze Command</a>.
</dd>
<dd>
This command moves the analysis forward by the specified number of
steps.
</dd>
</dl>
<h2 id="output_features">Output Features</h2>
<p>The OpenSees output features are used to monitor the model during
analysis. There are two types of output:</p>
<dl>
<dt>Recorders</dt>
<dd>
The OpenSees <a href="Recorder_Command" title="wikilink">Recorder
Command</a> specifies the location (Element or Node) and response type
(deformation or force) to record into a file throughtout the analysis.
</dd>
<dd>
The recorder data is only available after the analysis has been
terminated and the <a href="wipe_Command" title="wikilink">wipe
Command</a> is invoked or the OpenSees program is closed
</dd>
<dt>Real-Time data</dt>
<dd>
A series of <a href="RealTime_Output_Commands" title="wikilink">RealTime
Output Commands</a> are used to monitor the state of the model at any
time during the simulation
</dd>
</dl>
<h2 id="example_opensees_input">Example OpenSees Input</h2>
<p>&lt;h3&gt;Truss Example&lt;/h3&gt; <img src="FranksTrussExample.jpg"
title="FranksTrussExample.jpg" alt="FranksTrussExample.jpg" /></p>
<dl>
<dt>Build Model</dt>

</dl>
<p>
```Tcl
 model Basic -ndm 2 -ndf 2 node 1 0.0 0.0
node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 fix 1 1 1 fix 2 1 1
fix 3 1 1 uniaxialMaterial Elastic 1 3000.0 element truss 1 1 4 10.0 1
element truss 2 2 4 5.0 1 element truss 3 3 4 5.0 1 pattern Plain 1
“Linear” { load 4 100.0 -50.0 } 
```
</p>
<dl>
<dt>Static Nonlinear Analysis with LoadControl</dt>

</dl>
<p>
```Tcl
 constraints Transformation numberer RCM
system BandGeneral test NormDispIncr 1.0e-6 6 2 algorithm Newton
integrator LoadControl 0.1 analysis Static analyze 10

```
</p>
<dl>
<dt>Transient Nonlinear Analysis with Newmark</dt>

</dl>
<p>
```Tcl
 constraints Transformation numberer RCM
system BandGeneral test NormDispIncr 1.0e-6 6 2 algorithm Newton
integrator Newmark 0.5 0.25 analysis Transient analyze 2000 0.01

```
 <img src="GettingStartedGeometry.jpg"
title="GettingStartedGeometry.jpg" alt="GettingStartedGeometry.jpg" />
&lt;h3&gt;Plane Frame&lt;/h3&gt;</p>
<dl>
<dt>Build Model</dt>

</dl>
<p>
```Tcl
 model Basic -ndm 2 -ndf 3 node 1 0.0 0.0
node 2 504.0 0.0 node 3 0.0 432.0 node 4 504.0 432.0 fix 1 1 1 1 fix 2 1
1 1 mass 3 5.18 0.0 0.0 mass 4 5.18 0.0 0.0 geomTransf Linear 1 element
elasticBeamColumn 1 1 3 3600.0 4227.0 1080000.0 1 element
elasticBeamColumn 1 4 3 3600.0 4227.0 1080000.0 1 element
elasticBeamColumn 3 3 4 5760.0 4227.0 4423680.0 1 pattern Plain 1 Linear
{ load 3 0.0 -2000.0 -168074.0 load 4 0.0 -2000.0 168074.0 }</p>
<p>
```
</p>
<dl>
<dt>Gravity-Load Analysis</dt>

</dl>
<p>
```Tcl
</p>
<ol>
<li>create analysis &amp; perform analysis</li>
</ol>
<p>constraints transformation numberer RCM system BandGeneral test
NormDispIncr 1.0e-6 6 2 algorithm Newton integrator LoadControl 0.1
analysis Static analyze 10</p>
<ol>
<li>look at what happened to node 3</li>
</ol>
<p>print node 3 
```
</p>
<dl>
<dt>Cyclic Lateral Load Analysis</dt>

</dl>
<p>
```Tcl
</p>
<ol>
<li>set gravity loads constant &amp; reset time in domain</li>
</ol>
<p>loadConst -time 0.0</p>
<ol>
<li>create load pattern for lateral loads</li>
</ol>
<p>pattern Plain 2 Linear { load 3 200.0 0.0 0.0 load 4 200.0 0.0 0.0
}</p>
<ol>
<li>do some cyclic analysis</li>
</ol>
<p>foreach {numSteps stepSize} {10 0.1 10 -0.1 10 -0.1 10 0.1 10 0.1} {
integrator LoadControl $stepSize analyze $numSteps set time [getTime]
set disp [nodeDisp 3 1] puts “Time: $time Displacement $disp” }

```
</p>
