# Simple Parameter Study

<p>__NOTOC__ This example is intended for use with the OpenSeesMP
interpreter. It performs a series of sequential analysis in parallel.
The things of importance in the model are shown in the main script.
These are: 1) the use of for loops and variables to assign unique jobs
to the individual processors. 2) the use of unique names for the output
files from the recorders. 3) clean up of any extra files that are
generated but not needed.</p>
<p>The model and analysis are of little importance to the parallel
processing knowledge this article is trying to get across and so are not
included. They could be any model and any analysis.</p>
<p>The following is the main script set. This script is run by each of
the interpreters when the user starts the parallel computation.</p>
<p>&lt;pre&gt; set pid [getPID] set numP [getNP] set count 0;</p>
<p>source ReadRecord.tcl set g 386.4</p>
<p>foreach scaleFactor {0.5 0.75 1.0 1.5 2.0} { foreach gMotion [glob
-nocomplain -directory ./ *.AT2] {</p>
<p>if {[expr $count % $numP] == $pid} {</p>
<p>source model.tcl source analysis.tcl</p>
<p>set ok [doGravity]</p>
<p>loadConst -time 0.0</p>
<p>if {$ok == 0} { set gMotionName [string range $gMotion 0 end-4]
ReadRecord $gMotion $gMotionName$scaleFactor.dat dT nPts</p>
<p>timeSeries Path 1 -filePath $gMotionName$scaleFactor.dat -dT $dT
-factor [expr $g*$scaleFactor]</p>
<p>recorder EnvelopeNode -file $gMotionName$scaleFactor.out -node 100
-dof 1 doDynamic $dT $nPts</p>
<p>file delete $gMotionName$scaleFactor.dat } } incr count 1 } }
&lt;/pre&gt;</p>
