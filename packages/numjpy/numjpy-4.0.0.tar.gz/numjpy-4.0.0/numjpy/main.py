def main(stri):
    if stri == "minmax":
        text = "#divide_and_conqure_method\ndef getMinMax(low,high,arr):\n\t\n\t    if low == high:\n\t\t        arr_min = arr[high]\n\t\t        arr_max = arr[high]\n\t\t        return arr_max,arr_min\n\t\n\t    elif high-low == 1:\n\t\t        if(arr[high]>arr[low]):\n\t\t\t            arr_max = arr[high]\n\t\t\t            arr_min = arr[low]\n\t\t        else:\n\t\t\t            arr_max = arr[low]\n\t\t\t            arr_min = arr[high]\n\t\t        return arr_max,arr_min\n\t\n\t    else:\n\t\t        mid = (low + high)//2\n\t\t        arr_max1,arr_min1 = getMinMax(low,mid,arr)\n\t\t        arr_max2,arr_min2 = getMinMax(mid+1,high,arr)\n\t\t\n\t\t        if (arr_max1>arr_max2):\n\t\t\t            arr_max =arr_max1\n\t\t        else:\n\t\t\t            arr_max = arr_max2\n\t\t\n\t\t        if (arr_min1>arr_min2):\n\t\t\t            arr_min =arr_max2\n\t\t        else:\n\t\t\t            arr_min = arr_max1\n\t\t\n\t\t        return arr_max,arr_min\n\n\n# Driver code\narr = [1000,2000,3000,4000,6000,6000]\nhigh = len(arr) - 1\nlow = 0\narr_max, arr_min = getMinMax(low, high, arr)\nprint('Minimum element is ', arr_min)\nprint('nMaximum element is ', arr_max)\n\n\n\n\n#for_loop_method\nnumbers = [55, 4, 92, 1, 104, 64, 73, 99, 20]\nmax_value = None\nfor num in numbers:\n\tif (max_value is None or num > max_value):\n\t\tmax_value = num\nprint('Maximum value:', max_value)"

    elif stri == "binarysearch":
        text= 'import numpy as np\n\narr = np.random.randint(0,10000,100)\narr = sorted(arr)\nprint("Array is",arr)\nkey = int(input("Enter Key"))\nlow = 0\nhigh = len(arr)-1\n\n\ndef binary_search(arr,low,high,key):\n\n\twhile(low<high):\n\t\tmid = int((low + high) / 2)\n\n\t\tif (arr[mid] == key):\n\t\t\treturn mid\n\n\t\tif(arr[mid] < key):\n\t\t\tlow = mid + 1\n\n\t\telse :\n\t\t\thigh = mid - 1\n\n\treturn "not present in array"\n\nprint("Element is present at index",binary_search(arr,low,high,key))\n\n\n\n\nimport numpy as np\n\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (high + low) // 2\n\t\t\n\t\tif arr[mid] == x:\n\t\t\treturn mid\n\t\t\n\t\telif arr[mid] > x:\n\t\t\treturn binary_search(arr, low, mid - 1, x)\n\t\t\n\t\telse:\n\t\t\treturn binary_search(arr, mid + 1, high, x)\n\t\t\n\telse:\n\t\treturn -1\n\narr = np.random.randint(0,10000,100)\narr = sorted(arr)\nprint("Array is",arr)\nkey = int(input("Enter Key"))\n\nresult = binary_search(arr, 0, len(arr) - 1, key)\n\nif result != -1:\n\tprint("Element is present at index", str(result))\nelse:\n\tprint("Element is not present in array")'

    elif stri == "quicksort":
        text= 'import numpy as np\n\ndef partition(arr, low, high):\n\t    i = low\n\t    j = high - 1\n\t    pivot = arr[high]\n\t\n\t    while i < j:\n\t\t        while i < high and arr[i] < pivot:\n\t\t\t            i = i + 1\n\t\t\n\t\t        while j > low and arr[j] > pivot:\n\t\t\t            j = j - 1\n\t\t\n\t\t        if (i<j):\n\t\t\t            arr[i], arr[j] = arr[j], arr[i]\n\t\t\n\t    if (arr[i]>pivot):\n\t\t        arr[i], arr[high] = arr[high], arr[i]\n\t\n\t    return i\n\ndef quicksort(arr, low, high):\n\t    if (low < high):\n\t\t        partition_position = partition(arr, low, high)\n\t\t        quicksort(arr, partition_position + 1, high)\n\t\t        quicksort(arr, low, partition_position - 1)\n\n\narr = np.random.randint(0,10000,10)\nprint("Unsorted array is",arr)\nquicksort(arr, 0, len(arr) - 1)\nprint("Sorted array is:", arr)\n\n\n\n\n\n\n\nimport numpy as np\n\ndef partition(arr, low, high):\n\t    i = low\n\t    j = high - 1\n\t    pivot = arr[high]\n\t\n\t    while i < j:\n\t\t        while i < high and arr[i] < pivot:\n\t\t\t            i = i + 1\n\t\t\n\t\t        while j > low and arr[j] > pivot:\n\t\t\t            j = j - 1\n\t\t\n\t\t        if (i<j):\n\t\t\t            arr[i], arr[j] = arr[j], arr[i]\n\t\t\n\t    if (arr[i]>pivot):\n\t\t        arr[i], arr[high] = arr[high], arr[i]\n\t\n\t    return i\n\ndef partitionrand(arr, low, high):\n\t\n\t    randpivot = random.randint(low, high)\n\t\n\t    arr[low], arr[randpivot] = arr[randpivot], arr[low]\n\t    return partition(arr, low, high)\n\t\ndef quicksort(arr, low, high):\n\t    if (low < high):\n\t\t        partition_position = partitionrand(arr, low, high)\n\t\t        quicksort(arr, partition_position + 1, high)\n\t\t        quicksort(arr, low, partition_position - 1)\n\n\n\narr = np.random.randint(0,10000,10)\nprint("Unsorted array is",arr)\nquicksort(arr, 0, len(arr) - 1)\nprint("Sorted array is:", arr)'

    elif stri == "mergesort":
        text = 'import numpy as np\n\ndef mergeSort(arr, l, r):\n\n\t    if l < r:\n\n\t\t\n\n\t\t        m = l+ (r - l) // 2\n\n\t\t\n\n\t\t        mergeSort(arr, l, m)\n\n\t\t        mergeSort(arr, m + 1, r)\n\n\t\t\n\n\t\t        n1 = m - l + 1\n\n\t\t        n2 = r - m\n\n\t\t\n\n\t\t        L = [0] * n1\n\n\t\t        R = [0] * n2\n\n\t\t\n\n\t\t        for i in range(0, n1):\n\n\t\t\t            L[i] = arr[l + i]\n\n\t\t\n\n\t\t        for j in range(0, n2):\n\n\t\t\t            R[j] = arr[m + 1 + j]\n\n\t\t\n\n\t\t        i = 0\n\n\t\t        j = 0\n\n\t\t        k = l\n\n\t\t\n\n\t\t        while i < n1 and j < n2:\n\n\t\t\t            if L[i] <= R[j]:\n\n\t\t\t\t               arr[k] = L[i]\n\n\t\t\t\t                i += 1\n\n\t\t\t            else:\n\n\t\t\t\t                arr[k] = R[j]\n\n\t\t\t\t                j += 1\n\n\t\t\t            k += 1\n\n\t\t\n\n\t\t        while i < n1:\n\n\t\t\t            arr[k] = L[i]\n\n\t\t\t            i += 1\n\n\t\t\t            k += 1\n\n\t\t\n\n\t\t        while j < n2:\n\n\t\t\t            arr[k] = R[j]\n\n\t\t\t            j += 1\n\n\t\t\t            k += 1\n\n\t\n\n\n\narr = np.random.randint(0,100,10)\n\nn = len(arr)\n\nprint("Given array is", arr)\n\n\n\nmergeSort(arr, 0, n - 1)\nprint("\nSorted array is", arr)'

    elif stri == "selectionsort":
        text = 'import numpy as np\n\ndef selectionsort(arr):\n\t\n\t    for i in range(len(arr)-1):\n\t\t        mini = i\n\t\t        for j in range(i+1,len(arr)):\n\t\t\t            if(arr[j]<arr[mini]):\n\t\t\t\t                mini = j\n\t\t\n\t\t        if(mini != i):\n\t\t\t            arr[mini], arr[i] = arr[i], arr[mini]\n\t\t\n\t\n\nlist1 = np.random.randint(0,100,10)\narr = []\n\nfor i in range(len(list1)):\n\t    arr.append(list1[i])\n\nprint("Unsorted list",arr)\nselectionsort(arr)\nprint("Sorted list", arr)'

    elif stri == "insertionsort":
        text = 'import numpy as np\n\ndef insertionsort(arr):\n\t\n\t    for i in range(1,len(arr)):\n\t\t        key = arr[i]\n\t\t        j = i-1\n\t\t\n\t\t        while j>=0 and key < arr[j]:\n\t\t\t            arr[j+1] = arr[j]\n\t\t\t            j = j-1\n\t\t            \n\t\t        arr[j+1] = key\n\t\n\nlist1 = np.random.randint(0,100,10)\narr = []\n\nfor i in range(len(list1)):\n\t    arr.append(list1[i])\n\nprint("Unsorted list",arr)\ninsertionsort(arr)\nprint("Sorted list", arr)'

    elif stri == "knapsack":
        text='val1=[10,5,15,7,6,18,3]\nW =[2,3,5,7,1,4,1]\nn=len(val1)\nmaxval=0\nwt =15\nratio1=[]\nfor i in range(n):\n\t    ratio1.append(val1[i]/W[i])\n\nfor i in range(len(ratio1)):\n\t    k = ratio1.index(max(ratio1))\n\t    \n\t    if wt==0:\n\t\t        break\n\t    elif wt>=W[k]:\n\t\t        maxval= maxval+ratio1[k]*W[k]\n\t\t        wt= wt-W[k]\n\t\t        ratio1[k]=0\n\t    else:\n\t\t        maxval=maxval+ratio1[k]*wt\n\t\t        wt=0\n\t\t        ratio1[k]=0\nprint(maxval)\n\n\n\n\n\nimport random\nimport timeit\ndef knapSack(W, wt, val, n):\n\t    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n\t\n\t    # Build table K[][] in bottom up manner\n\t    for i in range(n + 1):\n\t\t        for w in range(W + 1):\n\t\t\t            if i == 0 or w == 0:\n\t\t\t\t                K[i][w] = 0\n\t\t\t            elif wt[i-1] <= w:\n\t\t\t\t                K[i][w] = max(val[i-1]\n\t\t\t\t                          + K[i-1][w-wt[i-1]],\n\t\t\t\t                              K[i-1][w])\n\t\t\t            else:\n\t\t\t\t                K[i][w] = K[i-1][w]\n\t\n\t    return K[n][W]\n\n# Driver code\nn = int(input("Enter number of items: "))\nval =random.sample(range(1,n+1),n)\nval = [int(v) for v in val]\nprint(val)\nwt =random.sample(range(1,n+1),n)\nwt = [int(w) for w in wt]\nprint(wt)\nW = int(input("Enter maximum weight: "))\n\nt1=timeit.default_timer()\nprint(knapSack(W, wt, val, n))\nt2=timeit.default_timer()\nprint("The time taken is:",t2-t1)'

    elif stri == "salesman":
        text='from sys import maxsize\nfrom itertools import permutations\nV = 4\n\ndef travellingSalesmanProblem(graph, s):\n\t	vertex = []\n\t	for i in range(V):\n\t\t		if i != s:\n\t\t\t			vertex.append(i)\n\t\n\t	min_path = maxsize\n\t	next_permutation=permutations(vertex)\n\t	for i in next_permutation:\n\t\t		current_pathweight = 0\n\t\t		k = s\n\t\t		for j in i:\n\t\t\t			current_pathweight += graph[k][j]\n\t\t\t			k = j\n\t\t		current_pathweight += graph[k][s]\n\t\t		min_path = min(min_path, current_pathweight)\n\t		\n\t	return min_path\n\n\nif __name__ == "__main__":\n\t	graph = [[0, 10, 15, 20], [10, 0, 35, 25],\n\t			[15, 35, 0, 30], [20, 25, 30, 0]]\n\t	s = 0\n\t	print(travellingSalesmanProblem(graph, s))\n'

    elif stri == "sumofsubset":
        text = 'def subset(set,sum,n):\n\t    if sum==0:\n\t\t        return True\n\t    elif sum!=0 and n==0:\n\t\t        return False\n\t    elif set[n-1]>sum:\n\t\t        return subset(set,sum,n-1)\n\t    else:\n\t\t        return subset(set,sum,n-1) or subset(set,sum-set[n-1],n-1)\n      \n\nset = [3, 34, 4, 12, 5, 2]\nsum = 18\nn = len(set)\nx = subset(set,sum,n)\nprint(x)'

    elif stri == "matrixchain":
        text = "import numpy as np\ndef matrix_product(p):\n\t    length = len(p) \n\t \n\t    \n\t    m = [[-1]*length for _ in range(length)]\n\t    s = [[-1]*length for _ in range(length)]\n\t \n\t    matrix_product_helper(p, 1, length - 1, m, s)\n\t \n\t    return m, s\n \n \ndef matrix_product_helper(p, start, end, m, s):\n\t\n\t    if m[start][end] >= 0:\n\t\t        return m[start][end]\n\t \n\t    if start == end:\n\t\t        q = 0\n\t    else:\n\t\t        q = float('inf')\n\t\t        for k in range(start, end):\n\t\t\t            temp = matrix_product_helper(p, start, k, m, s) \\n\t\t\t                   + matrix_product_helper(p, k + 1, end, m, s) \\n\t\t\t                   + p[start - 1]*p[k]*p[end]\n\t\t\t            if q > temp:\n\t\t\t\t               q = temp\n\t\t\t\t               s[start][end] = k\n\t \n\t    m[start][end] = q\n\t    return q\n \ndef print_parenthesization(s, start, end):\n\t    if start == end:\n\t\t        print('A[{}]'.format(start), end='')\n\t\t        return\n\t \n\t    k = s[start][end]\n\t \n\t    print('(', end='')\n\t    print_parenthesization(s, start, k)\n\t    print_parenthesization(s, k + 1, end)\n\t    print(')', end='')\n \n \nn = int(input('Enter number of matrices: '))\np = []\nfor i in range(n):\n\t    temp = int(input('Enter  P{}: '.format(i)))\n\t    p.append(temp)\ntemp = int(input('Enter P{}: '.format(n)))\np.append(temp)\n \nm, s = matrix_product(p)\nprint('The number of scalar multiplications needed:', m[1][n])\nprint('Optimal parenthesization: ', end='')\nprint_parenthesization(s, 1, n)\nprint('\n')\n\nfor i in range(1,7):\n\t    for j in range(1,7):\n\t\t        if(i<=j):\n\t\t\t            print(m[j][i],end=" ")\n\t    print('\n')\n    "

    elif stri == "lcs":
        text = '# Function to find lcs_algo\ndef lcs_algo(S1, S2, m, n):\n\tL = [[0 for x in range(n+1)] for x in range(m+1)]\n\t\n\t# Building the mtrix in bottom-up way\n\tfor i in range(m+1):\n\t\tfor j in range(n+1):\n\t\t\tif i == 0 or j == 0:\n\t\t\t\tL[i][j] = 0\n\t\t\telif S1[i-1] == S2[j-1]:\n\t\t\t\tL[i][j] = L[i-1][j-1] + 1\n\t\t\telse:\n\t\t\t\tL[i][j] = max(L[i-1][j], L[i][j-1])\n\t\n\tindex = L[m][n]\n\t\n\tlcs_algo = [""] * (index+1)\n\tlcs_algo[index] = ""\n\t\n\ti = m\n\tj = n\n\twhile i > 0 and j > 0:\n\t\t        \n\t\tif S1[i-1] == S2[j-1]:\n\t\t\tlcs_algo[index-1] = S1[i-1]\n\t\t\ti -= 1\n\t\t\tj -= 1\n\t\t\tindex -= 1\n\t\t\n\t\telif L[i-1][j] > L[i][j-1]:\n\t\t\ti -= 1\n\t\telse:\n\t\t\tj -= 1\n\t            \n\t# Printing the sub sequences\n\tprint("S1 : " + S1 + "\nS2 : " + S2)\n\tprint("LCS: " + "".join(lcs_algo))\n\t\n\tfor y in range(0,n):\n\t\tprint("length :",L[y])\n\nS2 = (input("Enter the first word:"))#QUESERASERA\nS1 = (input("Enter the second word:"))#COURSERA\nm = len(S1)\nn = len(S2)\nlcs_algo(S1, S2, m, n)'

    elif stri == "nqueen":
        text = 'N = 4\n\ndef printSolution(board):\n\t	for i in range(N):\n\t\t		for j in range(N):\n\t\t\t			print (board[i][j],end=' ')\n\t\t		print()\n\n\n\ndef isSafe(board, row, col):\n\t\n\t	for i in range(col):\n\t\t		if board[row][i] == 1:\n\t\t\t			return False\n\t\n\t	for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n\t\t		if board[i][j] == 1:\n\t\t\t			return False\n\t\n\t	for i, j in zip(range(row, N, 1), range(col, -1, -1)):\n\t\t		if board[i][j] == 1:\n\t\t\t			return False\n\t\n\t	return True\n\ndef solveNQUtil(board, col):\n\t\n\t	if col >= N:\n\t\t		return True\n\t\n\t	for i in range(N):\n\t\t\n\t\t		if isSafe(board, i, col):\n\t\t\t			board[i][col] = 1\n\t\t\n\t\t			if solveNQUtil(board, col + 1) == True:\n\t\t\t				return True\n\t\t\n\t\t			board[i][col] = 0\n\t\n\t	return False\n\ndef solveNQ():\n\t	board = [ [0, 0, 0, 0],\n\t			[0, 0, 0, 0],\n\t			[0, 0, 0, 0],\n\t			[0, 0, 0, 0]\n\t			]\n\t\n\t	if solveNQUtil(board, 0) == False:\n\t\t		print ("Solution does not exist")\n\t\t		return False\n\t\n\t	printSolution(board)\n\t	return True\n\nsolveNQ()\n'

    elif stri == "kruskal":
        text = 'def find(i):\n\t	while parent[i] != i:\n\t\t		i = parent[i]\n\t	return i\n\n\ndef union(i, j):\n\t	a = find(i)\n\t	b = find(j)\n\t	parent[a] = b\n\ndef kruskalMST(cost):\n\t	mincost = 0 \n\t\n\t	for i in range(V):\n\t\t		parent[i] = i\n\t		\n\t	edge_count = 0\n\t	while edge_count < V - 1:\n\t\t		min = INF\n\t\t		a = -1\n\t\t		b = -1\n\t\t		for i in range(V):\n\t\t\t			for j in range(V):\n\t\t\t				if find(i) != find(j) and cost[i][j] < min:\n\t\t\t\t					min = cost[i][j]\n\t\t\t\t					a = i\n\t\t\t\t					b = j\n\t\t		union(a, b)\n\t\t		print("Edge {}:({}, {}) cost:{}".format(edge_count, a, b, min))\n\t\t		edge_count += 1\n\t\t		mincost += min\n\t\n\t	print("Minimum cost= {}".format(mincost))\n\t\n\nV = 5\nparent = [i for i in range(V)]\nINF = float("inf")\ncost = [[INF, 2, INF, 6, INF],\n\t		[2, INF, 3, 8, 5],\n\t		[INF, 3, INF, INF, 7],\n\t		[6, 8, INF, INF, 9],\n\t		[INF, 5, 7, 9, INF]]\n\nkruskalMST(cost)'

    elif stri == 'allpair':
        text = 'INF = 9999\ndef printSolution(n, distance):\n\t    for i in range(n):\n\t\t        for j in range(n):\n\t\t\t            if(distance[i][j] == INF):\n\t\t\t\t                print("INF", end=" ")\n\t            else:\n\t\t\t                print(distance[i][j], end="  ")\n\t        print(" ")\n\ndef all_pair(n, G):\n\t    distance = G\n\t    for k in range(n):\n\t\t        for i in range(n):\n\t\t\t            for j in range(n):\n\t\t\t\t                distance[i][j] = min(distance[i][j], distance[i][k]+distance[k][j])\n\n\nG = [[0,4,11],\n     [6,0,2],\n     [3,INF,0],\n    ]\n\nn = 3\n# n = int(input("Enter number of vertices: "))\n#\n# G = []\n# print("Enter the entries rowwise:")\n#\n# for i in range(n):\n\t#     a =[]\n\t#     for j in range(n):\n\t\t#          a.append(int(input()))\n\t#     G.append(a)\n\nfor i in range(n):\n\t    for j in range(n):\n\t\t        print(G[i][j], end = "  ")\n\t    print()\nprint("-----------------------------------")\nall_pair(n, G)\nprintSolution(n,G)'

    elif stri == "dijkstra":
        text = 'import sys\n\ndef to_be_visited():\n\tglobal visited_and_distance\n\tv = -10\n\t\n\tfor index in range(number_of_vertices):\n\tif visited_and_distance[index][0] == 0 and (v < 0 or visited_and_distance[index][1] <= visited_and_distance[v][1]):\n\t\tv = index\n\treturn v\n\t\n\nvertices = [[0, 1, 1, 0],\n\t[0, 0, 1, 0],\n\t[0, 0, 0, 1],\n\t[0, 0, 0, 0]]\nedges = [[0, 3, 4, 0],\n\t[0, 0, 0.5, 0],\n\t[0, 0, 0, 1],\n\t[0, 0, 0, 0]]\n\nnumber_of_vertices = len(vertices[0])\n\nvisited_and_distance = [[0, 0]]\nfor i in range(number_of_vertices - 1):\n\tvisited_and_distance.append([0, sys.maxsize])\n\nfor vertex in range(number_of_vertices):\n\tto_visit = to_be_visited()\n\tfor neighbor_index in range(number_of_vertices):\n\t\n\tif vertices[to_visit][neighbor_index] == 1 and visited_and_distance[neighbor_index][0] == 0:\n\t\tnew_distance = visited_and_distance[to_visit][1] + edges[to_visit][neighbor_index]\n\t\n\tif visited_and_distance[neighbor_index][1] > new_distance:\n\t\tvisited_and_distance[neighbor_index][1] = new_distance\n\t\n\tvisited_and_distance[to_visit][0] = 1\n\ni = 0\n\n\nfor distance in visited_and_distance:\n\tprint("The shortest distance of ", chr(ord("a") + i)," from the source vertex a is:", distance[1])\n\ti = i + 1'

    elif stri == "grapgcoloring" :
        text = 'def graphColour(graph, m, colors, n):\n\tif m + 1 == n:\n\t\treturn True\n\t\n\tfor c in range(1, m + 1):\n\t\tif isSafe(n, graph, colors, c):\n\t\t\tcolors[n] = c\n\t\t\tif graphColour(graph, m, colors, n + 1):\n\t\t\t\treturn True\n\t\t\tcolors[n] = 0\n\n\ndef isSafe(n, graph, colors, c):\n\tfor i in range(n):\n\t\tif graph[n][i] and c == colors[i]:\n\t\t\treturn False\n\t\treturn True\n\n\nn = int(input("Enter the value of number of nodes (n): "))\nG = [[0 for coloumn in range (n)] for row in range (n)]\n\n\nfor i in range(n):\n\tfor j in range(n):\n\t\tprint("Enter adjacency matrix [", (i), "][", (j), "]: ")\n\t\tG[i][j] = int(input())\n\n\nm = int(input("Enter the value of number of colors (m): "))\n\ncolors = [0 for i in range(n)]\nif graphColour(G, m, colors, 0):\n\tprint("Solution is: ", colors)\nelse:\n\tprint("No solution")\n\n\n\n\ndef graphColour(graph, m, colors, n):\n\t    if m+1 == n :\n\t\t        return True\n\t\n\t    for c in range(1, m+1):\n\t\t        if isSafe(n, graph, colors, c):\n\t\t\t            colors[n] = c\n\t\t\t            if graphColour(graph, m, colors, n+1):\n\t\t\t\t                return True\n\t\t\t           colors[n] = 0\n\ndef isSafe(n, graph, colors, c):\n\t    for i in range(n):\n\t\t        if graph[n][i] and c == colors[i]:\n\t\t\t            return False\n\t    return True\n\nn = int(input("Enter the value of number of nodes (n): "))\nG = [[0 for coloumn in range (n)] for row in range (n)]\nfor i in range(n):\n    for j in range(n):\n\t        print("Enter adjacency matrix [", (i), "][", (j), "]: ")\n\t        G[i][j] = int(input())\n\nm = int(input("Enter the value of number of colors (m): "))  \n\ncolors = [0 for i in range(n)]\n\nif graphColour(G, m, colors, 0):\n\t    print("Solution is: ", colors) \nelse:\n\t    print("No solution")'

    elif stri == "naivestring":
        text = 'def search(pat, txt):\nM = len(pat)\nN = len(txt)\nfor i in range(N - M + 1):\n\tj = 0\n\twhile(j < M):\n\t\tif (txt[i+j] != pat[j]):\n\t\t\tbreak\n\t\tj += 1\n\t\n\tif (j == M):\n\t\tprint("Pattern found at index ", i)\n\n# Driver Code\ntxt = str(input("Enter text:"))\npat = str(input("Enter pattern:"))\nsearch(pat, txt)'

    elif stri == 'prims':
        text = '# Prims Algorithm in Python\nINF = 9999999\nN = 5\nG = [[0, 19, 5, 0, 0],\n\t     [19, 0, 5, 9, 2],\n\t     [5, 5, 0, 1, 6],\n\t     [0, 9, 1, 0, 1],\n\t     [0, 2, 6, 1, 0]]\n\nselected_node = [0, 0, 0, 0, 0]\nno_edge = 0\nselected_node[0] = True\n\n# printing for edge and weight\nprint("Edge : Weight")\nmin_cost = 0\nwhile (no_edge < N - 1):\n\t    \n\tminimum = INF\n\ta = 0\n\tb = 0\n\tfor m in range(N):\n\t\tif selected_node[m]:\n\t\t\tfor n in range(N):\n\t\t\t\tif ((not selected_node[n]) and G[m][n]):  \n\t\t\t\t\t# not in selected and there is an edge\n\t\t\t\t\tif minimum > G[m][n]:\n\t\t\t\t\t\tminimum = G[m][n]\n\t\t\t\t\t\ta = m\n\t\t\t\t\t\tb = n\n\tmin_cost = min_cost + int(str(G[a][b]))\n\tprint(str(a) + "-" + str(b) + ":" + str(G[a][b]))\n\tselected_node[b] = True\n\tno_edge += 1\n\nprint(min_cost)'

    else:
        text = "menu:\n1)minmax\n2)binarysearch\n3)quicksort\n" \
               "4)mergesort\n5)selectionsort\n6)insertionsort\n" \
               "7)knapsack\n8)salesman\n9)sumofsubset\n" \
               "10)matrixchain\n11)lcs\n12)nqueen\n13)kruskal\n14)allpairshortestpathwarshall" \
               "\n15)dijkstra\n16)graphcoloring\n17)prims\n18)naivestring  "
    return text

if __name__ =="__main__":
    print(main("sumofsubset"))








